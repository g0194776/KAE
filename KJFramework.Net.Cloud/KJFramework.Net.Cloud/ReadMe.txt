**************************************************************************
* 2011年5月4日 项目进度
**************************************************************************
1.将ReceivedMessageObject重新定义为结构体，意在减轻GC压力
2.增加了网络节点(NetworkNode)分发消息时的空引用判断




**************************************************************************
* 2011年6月8日 项目进度
**************************************************************************
1. 为了减少项目可控性的成本，加入了傀儡的概念。
2. 创建了傀儡网络节点(PuppetNetworkNode)
3. 创建了傀儡功能处理器(PuppetFunctionProcessor)
4. 创建了傀儡传输通道(PuppetTransportChannel)
5. 开始尝试建立一系列基础的傀儡功能处理器, 用来支持傀儡网络节点

---------------------------------------------------------
- 下一步要做的事情
---------------------------------------------------------
1. 尝试为傀儡网络节点添加获取配套的傀儡任务调度器(PuppetRequestScheduler)
2. 尝试为网络节点，增加一个外围的创建工厂，该工厂将会支持在不同场景下的不同网络节点智能创建
	例如：* 本地调试时，创建的是傀儡网络节点
		     * 网络连调时，创建的是真正的网络节点
			 * 等等




**************************************************************************
* 2011年6月9日 项目进度
**************************************************************************
1. 为NetworkNode添加了静态的Create方法，用于根据不同的场景来创造适合的网络节点
2. 为傀儡网络节点(Puppet network node)加入了创建傀儡调度器的能力(Puppet request scheduler)
3. 更加完善了某些场景下的傀儡功能处理器
4. 添加了傀儡访问器
5. 添加了傀儡访问器规则
6. 更新了傀儡传输通道的内部细节，增加了一些标示位和状态的赋值， 尝试触发了一些行为事件






**************************************************************************
* 2011年6月10日 项目进度
**************************************************************************
1. 更新了NetworkNode.Create方法，增加了自定义的傀儡功能处理器(Puppet function processor).
	当一个用户通过Create方法创建一个网络节点时，如果runtime被判定为puppet node, 那么将会在初始化
	所有的默认processor后，再使用用户自定义的processor进行覆盖操作




##################################################
# 下一步需要优化的地方
##################################################
1. RequestScheduler在得到IRequestTask的成功执行事件后，获取相应的TransportChannel显得很费力，这点需要改进。





**************************************************************************
* 2011年7月16日 项目进度
**************************************************************************
1. 对于RequestScheduler在调度一个Task时候，进行了优化。 免除了2次的常规集合查询。
2. 优化了RequestTaskPool内部的实现，现在的逻辑为： 只要初始化RequestTaskPool，就会为里面的每一个Task进行事件关联，
	这样做的好处是，当每次租借一个Task时就不用先关联时间了，退还的时候也不用注销时间了，省去了更多的CPU时间片，和委托链的操作
3. 修改了RequestScheduler中相应的对外操作签名，改动后感觉影响不大，因为受改动的这些操作接口对外经常是不建议高频率使用的，内部的优化已经完成
4. 建立了网络节点扩展类(NetworkNodeExtends)
5. 为网络节点添加了一个发送智能对象的扩展方法:
		void Send<T>(Guid channelId, T obj) where T : IntellectObject





**************************************************************************
* 2011年8月16日 项目进度
**************************************************************************
1. 将网络云框架内部的通信设施全部替换为通信信道模型(KJFramework.Net.Channels)
2. 优化了网络节点内部的部分逻辑，修改了构造函数，要求初始化的时候必须传入协议栈
3. 移除了无用的服务域设计
4. 移除了对于网络节点的扩展方法 void Send<T>(Guid channelId, T obj) where T : IntellectObject
	改为内置方法。
5. 为网络节点重写编写了单元测试
6. 修改了傀儡节点(Puppet node)的设计，以完成这次的更新
7. 修改了请求调度器(RequestScheduler)对于新消息的传递上下文呢。
	修改后的逻辑为，内部的上下文改为使用消息信道(MessageChannel)类型