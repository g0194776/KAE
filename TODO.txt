7月25日进度
------------------------------------------------
1. 初步完成了KAE宿主跟RRCS之间的注册流程
2. 初步完成了KAE宿主跟RRCS之间的注销流程
3. 为KAE宿主跟RRCS之间的注册机制增加了“注册来源字段”
4. 初步完成了ApplicationDynamicObject和真实Application之间的协同调用
5. 更新了KAE宿主进程启动时使用随机网络资源的分配方式
6. 修改了从HostChannel到ConnectionAgent中对于Tag字段值的使用规则


What's the next:
------------------------------------------------
1. 完成LightPerformanceCounter的编写, 并将此应用于KAEHost内部      √
2. 针对RRCS内部通过crc从数据库获取APP信息的场景做进程内缓存      √
3. 重写SystemWorker的ConfigurationProxy类，并支持接口传入callback函数      √
4. 为CSN增加配置信息变化的Publisher      √
5. 重写SystemConnectionPool，为其增加Multiple Socket Connection的支持      √




8月11日进度
------------------------------------------------
1. 为CSN增加配置信息变化的Publisher
2. 完成LightPerformanceCounter的编写, 并将此应用于KAEHost内部
3. 创建了一个VS插件，用于日后更加便利的使用KAE
4. 重写SystemWorker的ConfigurationProxy类，并支持接口传入callback函数

	其实我们的初衷很简单，就是希望KAE宿主	能够HANDLE所有的网络资源。我们不期待任何的KPP能拥有或者创建属于自己的网络资源。介于此，
	我们特地为KAEHost和KPP之间打通了一个隧道，好让来自KPP里面获取配置信息的方法调用能够路由到
	默认应用程序域(Default AppDomain)中的代码块上，这样一来我们就没必要让每个KPP都与CSN来一次亲密的接触。

	这样做的好处是显而易见的，因为我们只需要在KAE宿主中做好对于CSN服务的连接管理，反向更新订阅就够了。
	从KPP的加载速度上来讲，这一点也是至关重要的。我们特地为SystemWorker设计了一个精简的内部初始化方法“InitializeForKPP”。
	正式由于此方法，在KPP进行初始化的时候没必要再从CSN拿一遍所有的配置信息。这之间节省了连接的开销，通信的开销。
	从灵活度来讲，这样的做法会让底层的结构更加清晰，甚至于在KAE宿主级别可以定制这个进程内部所有KPP的通信基础资源。



	
What's the next:
------------------------------------------------
1. 重写SystemConnectionPool，为其增加Multiple Socket Connection的支持      √
2. 开始着手于设计动态负载的分发模块      √
3. 完善并走通从APP到KAEHost的Send RSP流程      √
4. 开始开发基于KAE的VS Tools









9月12日进度
------------------------------------------------
1. 重写了SystemConnectionPool，为其增加Multiple Socket Connection的支持
2. 初步完成了KAE宿主对于获取远程灰度升级策略脚本的支持
3. 改造SystemWorker让其支持设置灰度升级脚本的功能
4. 为KAE的CSN配置项加入了灰度升级的配置


What's the next:
------------------------------------------------
1. KAE的包裹清单(用于一次性打包装配一个崭新的KAE宿主)
2. SystemWorker支持在创建网络事务的时候传入上下文的资源信息
2. 开发基于KAE的VS Tools




10月22日进度
------------------------------------------------
1. 重构了KAE宿主的构造函数用于支持装配清单的设计
2. 为KAE宿主内部添加了装配清单功能的支持，并定义KAE宿主只能使用一种方式进行初始化操作
3. 为KAE宿主内部增加了相关日志输出
4. 为ITracing接口增加了DebugInfo方法，用于打印日志的同时将内容输出到Console控制台上
5. 增加了KAE信息站的项目(KAE Information Station)
6. 为KAE信息站规定了第一个用于查询KPP详细信息的HTTP级别RESTful风格接口





12月15日进度
------------------------------------------------
1. 移除了Application的abstract定义，将其InnerInitialize方法改为virtual的。
    这样的做法主要是为了让使用者更加轻松，因为如果使用者没有特殊需求的话，他完全可以不用创建一个
	新的Application派生类而仅仅是为了重写InnerInitialize方法。
	当然，将Application的abstract定义移除后，内部做了些特殊的支持。当Application Main File内部不包含
	任何Application后则使用基础类型进行替换。
2. 优化了MetadataMessageTransaction.SendResponse方法，这直接的使得使用者再也不用构造一个MessageIdentity作为
	RSP消息0x00位置的值了，在内部MetadataMessageTransaction进行了优化，用于自动计算RSP场景下的MessageIdentity
3. 为KPPDataStructure增加SetSectionField<T>方法




What's the next:
------------------------------------------------
1. 在讲一致性圆环的地址信息传入指定的Application后，这个数据应该被SystemWorker所使用到。
	这就意味着不论是HOST还是APP都应该使用SystemWorker进行指定远程APP的请求发起。而SystemWorker
	内部使用的网络信息应该是初始化并且注入更新的。
2. 完善更多的测试用例
3. 改造SystemWorker内部的实现，将高度组合的方案替换为加工模式。即SystemWorker近用于内部能力和获取已初始化好的TransactionProxy
	伪代码看起来如下：
			IMessageTransactionProxy<T> proxy = SystemWorker.GetTransactionProxy(Protocol.BaseMessage);
			IMessageTransaction<T> transaction = proxy.Create[Oneway]Transaction(new Protocol(6,6,6), [RESOURCE URL]);
4. 完成KAE Official Application的搭建






12月17日进度
------------------------------------------------
1. 改造SystemWorker内部的实现，将高度组合的方案替换为加工模式。即SystemWorker仅用于内部能力和获取已初始化好的TransactionProxy
	伪代码看起来如下：
			IMessageTransactionProxy<T> proxy = SystemWorker.GetTransactionProxy(Protocol.BaseMessage);
			IMessageTransaction<T> transaction = proxy.Create[Oneway]Transaction(new Protocol(6,6,6), [RESOURCE URL]);
2. 将KatamaRing应用于SystemWorker中。现在我们已经将SystemWorker变为纯静态的类型，并且在KAE应用内部的Processor中可以使用SystemWorker
	来发起一个向远程APP的请求了
3. 抽象了IProtocolStackContainer, 用于内部管理已注册的网络协议栈
4. 移除了KAE Application内部对于DynamicDomainComponent中一些无用处方法的依赖
5. 从KAE的分支中移除了KJFramework.ServiceModel项目，这个项目本身就是WCF的学习作品，以后也不会再有升级打算了
6. 从KAE的分支中移除了KJFramework.Net.Cloud项目，这个项目的概念已经不适用于KAE了
7. 提供新的KAEResourceUri类型，这个类型将会被用于KAE判断路由灰度策略，这个Uri是可以让使用者来填写的
8. 为KatamaRing提供了更好的外部暴露方法
9. 完全重写了NetworkCluster的实现
10. 翻新了FailMessageTransaction的内部实现，剔除无用的代码
11. 深度重构了TransactionManager
12. 深度重构了ConnectionPool
13. 深度重构了网络协议栈的概念(Protocol Stack)，现在，网络协议栈不再是泛型的类型了
14. 剔除了KJFramework.Dynamic项目中Visitor的技术方案，用于让KJFramework.Dynamic更专注于动态组件技术
15. 全局解决方案的适应性修改



What's the next:
------------------------------------------------
1. 完善更多的测试用例
2. 完成KAE Official Application的搭建





12月18日进度
------------------------------------------------
#Updated local CSN database.
#Completely removed tunnel conception from "KJFramework.Dynamic" project.
#Added a new tunnel property to KAE's application class.
#Adjusted the calling position of InitializeCore method in SystemWorker.
#Added a new transfer field(Transaction Expire Time) for all kinds of network transaction.
#The business message transaction can automatically calculate "MessageIdentity.DetailId" in the "SendResponse" method now.


What's the next:
------------------------------------------------
1. 完善更多的测试用例
2. 完成KAE Official Application的搭建