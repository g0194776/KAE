**********************************************************************************
*
*	KJFramework.Messages 智能二进制消息框架
*
**********************************************************************************
1. 已经初步完成了对于消息内部类型的支持(int, short, long, uint, ushort, ulong, bool ,float, double, byte, byte[], DateTime, IntPtr)
2. 支持内部序列化元数据，只要将需要序列化的类实现IClassSerializeObject接口即可自动实现元数据转换。
3. 对于智能对象内部的“智能对象”提供支持。 支持迭代元数据转换。


[说明：]
    KJFramework框架中内置了一套，可以将网络传输实体自动转换为二进制元数据的能力框架。
使用此框架，将使得用户不在关心底层传输时对于二进制编码/解码的繁琐过程，解放程序员的脑力劳动。
目前此内置框架被初步定义在命名空间：KJFramework.Messages内，拥有独立Assembly.
    对于智能二进制消息框架, 内部提供了对于诸多类型的支持，甚至可以用于在不编写序列化代码的情况下，
将一个网络传输实体转换为二进制操作。
	这一切的操作，都全部由内部框架完成，通过简单的属性标签，就可以实现很强大的转换功能。
	目前智能二进制消息框架中，仍保留了内部扩展能力，日后扩展后，将会通过配置文件来增强配置能力。



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2010-05-18 更新
*
**********************************************************************************
1. 增加了对于数组的支持(暂时不支持泛型)。
在数组中的元素类型将会被默认支持(无论是需要序列化的，还是默认类型，或者是只能类型)。
2. 增强了异常捕获。



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2010-06-22 更新
*
**********************************************************************************
1. 修改了当判断数据类型时，先判断数组的BUG。 



###################################################
#	修改方案：
#	1. 增加可扩展对象概念，支持平滑的协议升级，兼容新协议。
#	2. 尝试增加自定义消息格式化器，允许使用方根据一个消息格式
#	    器来进行消息的转换处理。
#  3. 对于同一个项目，不同消息的元数据拆分问题。（是否考虑使用拆分规则？，OR 使用原有职能对象进行类型分析？）
###################################################




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2010-07-19 更新
*
**********************************************************************************
1. 已经完成了可扩展对象的设计与编码工作，并且能够支持平滑的协议升级，以及兼容新协议。
2. 已经初步允许第三方人员使用该框架进行消息结构的自定义，并且已经能够自定义消息格式化器。



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2010-07-29 更新
*
**********************************************************************************
1. 增加了智能类型分析器
2. 增加了分析器的概念（一个类型分析器用来分析并将分析的结果进行保存。 一个智能类型的分析是很耗时的，
所以需要采用缓存的手段减少对于相同类型的再次分析。通过启用分析器的概念，使得在频繁对于指定对象的
拆分和解析中，使用缓存中的分析结果即可，节省了CPU时间片和BLOCK的时间。）
[注]：第三方消息结构引擎并没有应用此次新增的概念。


**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2010-09-01 更新
*
**********************************************************************************
1. 添加了对于DateTime类型的支持。
2. 修改了Pickup一个对象后，改对象的IsPickup属性为false的BUG。


**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2010-10-05 更新
*
**********************************************************************************
1. 增加了对于智能对象的“热缓存”概念，使用“热缓存”将会使序列化到字节数组的速度更加快捷，
   而且在对象引擎中也修改了部分代码，用来提供基础支持。
2. 完美支持了枚举类型。



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-04-18 更新
*
**********************************************************************************
1. TLV中的Length类型由short改为了int. (累死我了)
	哦，这是一个令人沮丧的改变，因为之前的序列化规则中没有想到的是，会有一个对象复杂到需要30000个BYTES都无法满足，
	当这样的场景出现时，我们设定的Length类型为short,就已经超出其的范围了，我们不得不找寻一个更大的单位来保证程序的运行。






**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-06-21 更新
*
**********************************************************************************
1. 更新了IntellectObjectEngine.GetObject的逻辑，将内部字典的操作从ContainsKey->Indexer
	改为了TryGetValue, 进一步提升操作性能

	

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-07-11 更新
*
**********************************************************************************
1. 为智能对象引擎(IntellectObjectEngine)增加了预热(Preheat)方法.
2. 优化了IntellectObjectEngine.GetObject解析bytes时计算offset的逻辑.
3. 删除了部分类库中实现了IDispose接口的逻辑，删除了析构函数.
4. 删除了IntellectTypeProcessorMapping中的同步对象锁, 删除这部分的逻辑是因为，我们期望所有
	智能类型处理器的注册任务都应该在程序初始化的时候来完成。



	
**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-08-25 更新
**********************************************************************************
1. 重写了IntellectObjectEngine.ToBytes(IIntellectObject obj)方法。
2. 经过优化后，序列化后的二进制更小了，而且内部还集成了对于特殊值类型的优化方案。
	比如，如果字段是int类型，则不带Length了，这样一来也就节省了一笔开销.
3. 重写了内部序列化数组结构的实现方式，由原来的Array element = TLV
	改为现在的：Array element = LV.  这里省去了T， 如果当前的元素内容为null, 则L = 0.
4. 为IntellectObjectEngine.ToBytes(IIntellectObject obj)方法编写了单元测试.
5. 创建了VT类型，用于标记某些需要内部优化的值类型.
6. 由于内部序列化数组结构得到了优化，也就不存在了T不够用的问题。




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-08-26 更新
**********************************************************************************
1. 重写了IntellectObjectEngine.GetObject<T>(Type target, byte[] data)方法。
2. 经过再三考虑后，决定还是去除了序列化数组时开头的4个字节 rank.
3. 重写了内部反序列化数组结构的实现方式，内部将会分为2种：
	(1). 使用VT.Size来截取字节流
	(2). 使用dynamic length来截取字节流
4. 为IntellectObjectEngine.GetObject<T>(Type target, byte[] data)方法编写了单元测试.
5. 创建了TempParseStruct用于临时存储解析数据所需要的信息
6. 优化了若干处类型的判断，比如将"Property.Value is Array"替换为"Property.PropertyInfo.PropertyType.IsArray".
7. 增加了DateTime类型为fixed data length type.





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-08-29更新
**********************************************************************************
1. 修改了一处判断类型是否为VT的BUG， 现在的逻辑为：
	如果当前字段类型是枚举，则取到该枚举的真正类型，然后再判断VT
2. 为了庆祝此次智能二进制消息框架的升级，特此提升版本号为：2.0.0.0



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-08-30更新
**********************************************************************************
1. 减少了Pickup data时二进制数组的create or copy的工作量.
2. 重构了IntellectObjectEngine.GetObject<T>(Type target, byte[] data)方法。
	重构后，该方法内部更加清晰，经过代码优化，减少了一层循环，使得解析代码更加快速(已经能够攀比序列化方法的速度了)
3. 创建了实例帮助器(InstanceHelper)用来支持GetObject<T>方法的重构
4. 添加了对于托管指针(IntPtr)的序列化和反序列化支持
5. 添加托管指针(IntPtr)为固定长度(Fixed Length)数据类型
6. 优化了IntellectTypeProcessorMapping类




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-08-31更新
**********************************************************************************
1. 重写了GetObjectIntellectTypeAnalyser.Analyse方法
2. 重写了ToBytesIntellectTypeAnalyser.Analyse方法
3. 解决了当一个智能对象中存在索引器字段时，无法序列化的问题




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-08-31更新
**********************************************************************************
1. 重写了IntellectObjectEngine.GetObject<T>方法
2. 编写了IntellectObjectEngine.GetObject<T>方法的重载，用于内部计算Offset
3. 为IntellectTypeProcessor增加了用于非托管计算的方法
4. 为IntellectTypeProcessor增加了用于非托管计算的支持标示: IIntellectTypeProcessor.SupportUnmanagement
5. 重写了数组类型处理器内部GetObject的算法
6. 从今天开始，KJFramework.Message框架内部的解析工作，全部由托管解析改为非托管解析！
	更改后的好处：  减少了字节数组的copy， 直接的缓解了GC的压力，以及减少了CPU的时间片！
	也就是说整个的解析过程中，将不会再创建新的字节数组，只是用入口传入的字节数组即可。




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-09-15更新
**********************************************************************************
1. 修改了ByteArrayIntellectTypeProcess.SupportUnmanagement =  true.
2. 重写了(unmanaged) ByteArrayIntellectTypeProcess.Process()方法
3. 修正了无法正确解析byte[]类型字段值的问题。




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-09-19更新
**********************************************************************************
1. 修正了序列化一个对象时，没有按照Property.Id的顺序进行序列化的问题
2. 修正了(unmanaged) ByteArrayIntellectTypeProcess.Process()方法中计算字节偏移量的BUG




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-10-08更新
**********************************************************************************
1. 修正了NormalArrayIntellectTypeProcessor对于Process()方法传入length = 0的BUG






**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-10-26更新
**********************************************************************************
1. 清除了内部IntellectObject对象对于的代码
2. 废除了对于支持第三方协议栈的代码，日后需要重新设计
3. 更新了部分代码
4. 更新了README.TXT




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-10-27更新
**********************************************************************************
1. 为智能对象添加了描述自身信息的能力
	#调用方式 IntellectObject.ToString();
2. 更新了README.TXT




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-10-31更新
**********************************************************************************
1. 进一步的提升了序列化和反序列化的速度
	#序列化平均100000个复杂对象，平均在2秒左右(Debug Mode), 1.3秒左右(Release Mode)
	#反序列化平均100000个复杂对象，平均在1.6秒左右(Debug Mode), 1秒左右(Release Mode)
2. 更新了README.TXT




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-01更新
**********************************************************************************
1. 重新调整了序列化时候的初始化集合类型，从Dictionary<T, K>改变为IList<T>,
    #这样的调整使得在大规模对象序列化的场景下，能够节省更多的内存空间。
	#另外还有一个好处，就是在大规模对象序列化的场景下，能比原来总时间平均快 60+ms.
2. 更新了README.TXT



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-02更新
**********************************************************************************
1. 为IntellectObject.ToString()方法应用了新的优化方式，比原有的速度快 1.5s+
2. 更新了UPDATE.TXT






**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-11更新
**********************************************************************************
1. 解决了ulong类型无法解析的BUG
2. 添加了对于 Sbyte类型的序列化和反序列化支持
3. 添加了对于 Decimal类型的序列化和反序列化支持
4. 更新了README.TXT




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-11更新
**********************************************************************************
1. 优化了每一个字段第一次反序列时的性能
2. 更新了README.TXT





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-18更新
**********************************************************************************
1. 优化了分析器中对于类型唯一标识的代码，从Type.FullName改为Type.MetadataToken,
    这样的做法，是因为访问Type.FullName时，将会使得RuntimeType不得不在底层进行全字符串的拼接工作。
2. 将保存VT的字典，由Dictionary<Type, VT>改为Dictionary<int, VT>
3. 为IntellectObjectEngine中的反序列化能力提供了重载方法IntellectObjectEngine.GetObject<T>(byte[] data)
4. 在序列化对象的过程中，将提取每一个字段的新值从分析器中提出，改为在序列化的过程中去提取当前值
5. 性能提升：
    #序列化对象，性能平均提升 100+ms.
	#反序列化对象，性能平均提升 50+ms.
6. 在单元测试的项目中加入了关于“差异检测”的测试方法
7. 更新了README.TXT





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-21更新
**********************************************************************************
1. 将判断是不是固定字节数的能力代码搬出IntellectTypeAnalyser， 改为FixedTypeManager.
2. 创建了静态类FixedTypeManager，用于专门维护固定字节数类型的相关能力。
3. 开放了FixedTypeManager类型，这样一来，使用者就可以加入自己所期望的固定字节数类型了，是不是很帅？
    #比如: 
	  如果一个使用者，自己的系统中有一个标示用户唯一标示的类型: UID.  但是，这个类型如果序列化的话，
	  会遵循TLV的格式，如果您已经为UID类型定制了固定预知字段，那么每次的L其实是多余的。所以，开始尝试使用
	  我们这次的FixedTypeManager类型类型吧！
    #使用方式:
	  还以上面的UID类型为例，我们只需要为UID类型创建自身的IntellectTypeProcessor,加入到当前的处理器集合中，
	  这样的做法，就为UID类型做好了序列化和反序列化的支持。 剩下的一步，就与这次的更新有关，我们还需要在程序
	  初始化的时候插入如下一句话:
	        FixedTypeManager.Add(typeof(UID), [fixed data length]);
	  这样一来，每次序列化UID的时候，将会少去L(长度)这4个字节!
4. 增加了针对本次更新的相关单元测试， 如果您不懂得如何使用，就去看我们这次更新的单元测试吧！
5. 更新了README.TXT





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-11-23更新
**********************************************************************************
1. 为IntellectTypeProcessor添加了重载方法
    public void Process(byte[] memory, int offset, IntellectPropertyAttribute attribute, object value);
	这样做法的好处是，可以尽可能的省去一次字节数组内存COPY.
2. 添加了BitConvertHelper类，这个类的主要能力，就是能够阻止一次内存COPY, 好吧，我们来谈论一下这个问题。
    当我们有一个字节数组，比如初始化大小为5，看起来就像是这样:
	      byte[] data = new byte[5];
    如果我们想将一个int类型的值变为字节数组，并且存入上述的这个字节数组，那么，通用的做法是:
	      1. 将一个int类型的值转变为字节数组，通常使用 BitConverter.GetBytes(int value).
		  2. 再使用Buffer.BlockCopy方法，将上述转换过后的字节数组，复制到那个5字节的数组中。
    而，这个类加入的目的，就是使得减少刚才所说的第二步，也就是说，将一个int类型的值直接转换为字节数组，并且直接存储到指定字节数组中。
	请不要将这个类的目的，仅仅想象成为上述2步的组合版，那就大错特错了。
3. 修改了数组类型序列化时的热缓存，将原本数组序列化的大泥球，详细拆分为多种场景的热缓存，这样做的好处是，
    使得序列化数组的时候，更加高效， 哦，是的，到底有多高效？ 让我们来看一下性能提升的参数吧。
4. 序列化性能提升
    在我们的复杂对象测试场景下(这个复杂对象中，数组相对来说比较多)，序列化速度平均提升1.2s+
	当然，如果自定义类中，不存在数组类型，那么相对来说，相对速度的提升仅仅是200ms+
5. 增加了相关的单元测试
6. 由于序列化方面的性能提升，直接的减小了内存的COPY，以及直接的减小了GC的压力
7. 更新了README.TXT
    

	

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-12-12更新
**********************************************************************************
1. 将Analysers内部获取分析结果的key由Type.MetadataToken改为了Type.FullName
    改回来的原因是因为，我们在使用的场景中，碰到了不同程序集，不同的Type，但是相同的Type.MetadataToken的情况.



	

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2011-12-18更新
**********************************************************************************
1. 增加了对于可空类型的序列化/反序列化支持
    (1). 这是一个令人振奋人心的消息，不是吗？ 当我们定制协议的时候，再也不会为了某些值类型的协议字段是否需要下发而苦恼了！
	      现在，一切都变得更加美好，如果我们在定制自定义实体的时候，期望某些值类型字段在某些场景下不需要参与序列化，以省去
	      消息序列化的大小，那么，尝试把这些字段设置为可空类型吧(比如 int?,double?,short?......等等).
    (2). 通过对于可空类型序列化/反序列化成本的评估，我们发现，为当前框架加入此能力，并不会明显的拖慢原有框架性能，
	      只会在原有速度上平均慢去 60~100ms+(量级序列化/反序列化的效果), 所以，我们认为这种成本是可以接受的。 
2. 增加了对于可空类型序列化/反序列化的多个单元测试
3. 更新了Readme.TXT





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-01-11更新
**********************************************************************************
1. 将FixedTypeManager内部获取分析结果的key由Type.MetadataToken改为了Type.FullName
    改回来的原因是因为，我们在使用的场景中，碰到了不同程序集，不同的Type，但是相同的Type.MetadataToken的情况.







**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-02-18更新
**********************************************************************************
1. 修改了一个BUG，此BUG会导致序列化的0元素数组在解析的时候会失败，
    这是由于原来的代码中在解析策略里面并未检测数组的初始元素个数所导致的，现在该问题已经被修复。
2. 为修复此BUG建立了相关的单元测试





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-02-20更新
**********************************************************************************
1. 添加了基础能力类型 - BitFlag
   框架内部添加此基础能力类型能够更好的，更简单的解决开发人员对于Bit的操作和判断，并且此类型
   在框架内部是支持序列化的，而且只占用1个字节，这样为我们以后的开发带来了更多的便利性。
2. 添加了对于IPEndPoint的序列化支持(Fixed size: 12).
3. 添加了以上改动所需要的单元测试





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-02-22更新
**********************************************************************************
1. 优化了Guid类型的序列化代码，提升了性能
2. 增加了Guid类型的序列化/反序列化单元测试，以及关于此类型的量级序列化/反序列化单元测试






**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-02-28更新
**********************************************************************************
1. 优化了数组的解析策略，重新设计了关于数组元素类型热缓存的粒度问题
    #Debug Mode: 速度快了将近 300ms+.
    #Release Mode: 速度快了将近 300ms+.
2. 在序列化数组元素的时候，我们特地进行了优化，以至于减少了2次没必要的内存COPY
3. 增加了对于TimeSpan类型的序列化/反序列化支持
4. 添加了序列化/反序列化TimeSpan类型的相关单元测试





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-03-13更新
**********************************************************************************
1. 增加了DataHelper, 这是一个轻量级的序列化/反序列化帮助器
   哦，是的，框架中除了需要为智能对象提供序列化/反序列化之外，我们的程序中
   还会经常涉及到一些其余数据类型的二进制数据操作，在以往，我们不得不单独为
   这些类型做数据处理， 现在，这一切都会变得容易起来，那就是我们提供了轻量级的
   DataHelper! 好吧，当你的工作中涉及到int, long, array,等等小数据类型的二进制操作时，
   就来尝试一下吧。




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-04-18更新
**********************************************************************************
这是一次，针对 固定字节数量类型的数组优化。 我们为一些常用的数组类型定制了
极致性的托管指针优化方案，通过这个解决方案，直接降低了GC的压力，指定数组类型
在具有更多元素的场景下序列化/反序列化，将会更快速！
	这次更新所影响的数组类型: int[], short[], float[], bool[], Guid[], double[]
	经过测试后我们不难发现，此次更新将会在特定场景中平均比原来的解决方案快一倍！
	特定场景如下:
		#智能对象内部含有多个数组，并且数组的类型为这次更新所支持的类型
		#数组元素很多

好吧，我们来看一下这次更新的具体改动:
-----------------------------------------------------------
1. 修改了序列化/反序列化引擎的处理流程，为特定类型的数组做特殊优化处理
2. 为这次更新所支持的数组类型新建了ArrayProcessor.
3. 向外部公开了一个数组优化处理器映射类ArrayTypeProcessorMapping，如果使用者不使用此类
    则除去本次更新以外的数组类型都会走原来的老分支逻辑。 如果使用者为指定类型数组创建processor
	并注册到开放的映射类中，我们的引擎将会优先使用已经注册的相应processor!






**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-05-03更新
**********************************************************************************
1. 修改了一个BUG，该BUG会导致即使标记了IsRequire = true的字段也会在有些时候，在缺少值得情况下
   躲避安全检测。
2. 为IsRequire标记创建了单元测试
3. 将序列化内部的检测流程提前



**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-05-24更新
**********************************************************************************
1. 我们不难发现，在数据的传输中，如果在特定的场景下，对于数组的元素数量需求很高，那这将是一个很大的性能瓶颈。
   经过测试，我们定义：数组元素个数10，为性能瓶颈的边界值，如果一个数组元素超过此数量则会产生非常大的性能瓶颈。
   所以，就在现在，我们特地为常用的数组类型增加了对于超大量数组元素个数的高性能支持，这是一个令人兴奋的优化点。
   此次优化所涉及的数组元素类型有： int[], short[], float[], double[], byte[]
2. 除此之外，我们还发现，原来框架中对于byte[]类型的序列化/反序列化并没有提供很好的高性能支持，本次更新中，我们特地
   提供了对于这个类型的高性能序列化/反序列化实现。
3. 为本次的更新提供了相关的单元测试




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-07-07更新
**********************************************************************************
   不得不说的是，这是一次非常重要的更新。这次的更新，标志着KJFramework.Message
序列化框架已经脱胎换骨了。经过我们的思考，在以往的序列化/反序列化中，经常困扰我们的
性能问题，无外乎就2个。 那就是“GC的压力”以及“内存COPY很频繁”的问题。
   在本次的更新中，我们将为您解决上述的2个问题。 好吧，让我们来谈谈本次更新。

1. 引入了非托管内存池，为对象序列化提供了直接的优化，这样的做法，使得高频度的对象序列化，
    所造成的GC压力直接降为最低。
	      在以往的测试中，我们发现，由于高频度的序列化对象所造成的GC压力越来越大，这直接的原因，那就是
	我们无法做到预测对象的大小，以便于直接开辟出一块足够的空间来完成“无需字节数组拼接”的序列化操作。
	但是，慢慢的，这一切将会拖慢您的应用程序，因为对象的序列化已经占用了大多数的GC时间，这是一个
	很糟糕的情况，所以，本次的更新将会为您解决这个问题。
2. 解决了99%的拆装箱内存COPY问题。 
           好吧，让我们来谈论一下这个问题，在以往的设计中，无论可序列化对象的字段是什么类型，我们都会将这个字段
	的值转变为object然后再去处理，当时，KJFramework.Message的设计使得我们无法去避免这个问题。这是个拥有
	坏味道的设计，不是吗？ 由于高频度的对象序列化，所产生的大量拆、装箱情况，已经引起了我们足够的重视。
	在本次的设计中，我们已经为您带来针对这个问题的最终解决方案，那就是 - 避免拆、装箱的发生。
	      我们特地为每一个可序列化字段设计了基于MSIL的动态基础单元，这是个重点，这个MSIL动态基础单元的出现，
    直接避免了任何的拆，装箱行为。然后，仅仅是这样还是不够的，于是，我们又将所有的字段序列化操作滞后到
	每一个单独的类型处理器中，我们相信，只有每一个处理器中，才知道它们自己要处理的是什么类型，所以，当滞后的
	序列化操作加上一个动态的MSIL基础单元，这个问题也就迎刃而解了，这一切都是那么的完美，那么的优雅。
	     我们还为IIntellectTypeProcessor设计了新的序列化重载方法，我们建议，所有编写或者基于原有老接口的使用者，都去实现
    这个新的重载操作，我们相信，您将会喜欢上这个新方法的。
	     最后，我们再来说一下，为什么这次所带来的解决方案只解决了99%的拆、装箱问题，那是因为，我们的框架还要支持
    可空值类型，它的出现，会为我们带来一部分的拆、装箱损耗。
3. 完整的类型大小定义方案
         在KJFramework.Message原来的设计中，每一个类型的序列化或者反序列化都是在代码中直接写死了该类型所占用的字节数，
    众所周知，这种行为是非常不好的，那么本次的更新中，这个问题我们也给出了解决方案。一个新的类型"Size"出现了，
	他的出现解决了上述问题。 一切的类型所占用字节数都是由sizeof运算符所计算出的。
4. 规范了异常类型
         在KJFramework.Message原来的设计中，所抛出的只有一些.NET的基础异常类型，我们一直都期望，能定义出符合规范的自定义异常类型，
    以及规格化的异常输出信息。当然，这一点在本次更新中也有所体现，比如，我们设计了一个新的异常类型"PropertyNullValueException"以及
	一个新的异常信息规格化类"ExceptionMessage"。
5. 创建了一套规范化的非托管操作API
         由于在本次的更新中，我们引入了非托管内存池的机制，这也就不得不牵扯到操作非托管内存的API。请不用担心，我们为这套系统设计了一套
   非常易用的非托管内存操作API，利用这套API，我们相信，当您使用我们的KJFramework.Message做二次开发时，将变得更加得心应手。
6. 全类型支持的大规模元素数组序列化优化
         在上一个版本中，我们公布出了很少类型的大规模元素数组序列化优化方案，在本次中，我们的系统已经支持了全部类型的数组优化方案！这是一个
   令人激动人心的时刻，当您的业务中，需要大量数组元素参与网络传输的时候，您才会发现本次更新的重要性。
7. 更详细的单元测试
         在本次版本的更新中，我们加入了更多的单元测试用例，来更加完整的测试我们的系统。
8. 修改了系统中存在的一些BUG
9. 修整了整体系统代码，让这个框架代码变得更加整洁







**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-07-11更新
**********************************************************************************
1. 解决了一个BUG
    此BUG为：当智能对象的内部内嵌有一个智能对象，并且该对象为空时，会抛出空指针异常.





	

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-07-16更新
**********************************************************************************
1. 解决了内部多Memory Segment内存COPY时候的偏移错误。
   这个错误将会导致您在序列化大型数组或者字符串的时候，得到的二进制数据是错误的。
2. 优化了Giveback机制




**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-08-10更新
**********************************************************************************
      在本次的版本更新中，我们为KJFramework.Message提供了向前兼容的解决方案。
好吧，这其实是一个很家常的话题，我们就来说一下，在KJFramework.Message中是如何
做到的。
      首先，由于KJFramework.Message的设计原因，每一个可序列化的实体都会拥有标记有
[IntellectProperty]的Property, 并且每个字段所提供的标记序号是不同的。那么，我们提供的
向前兼容方案是：
      假设实体A拥有2个可序列化字段，分别标记为(0, 1)。
	  假设实体B派生自实体A，并且多出一个可序列化字段，我们标记为(2).
	  那么，当实体B的二进制数据用作解析实体A的时候，实体A只会被解析出它自己本身拥有的2个
可序列化字段(0, 1)，这时实体A的CompatibleMode字段值为true, 这表示当前实体A是使用的
其他多于本身实体定义字段的数据所解析的。当您尝试把这时候解析出来的实体A写入日志时
（调用实体A的ToString方法），在日志中也会体现出本次实体A是以兼容模式进行解析的。







**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-08-23更新
**********************************************************************************
1. 增加了"值类型字段，默认值不参与传输"的新功能。
    哦，是的。 这是一个令人兴奋的新功能！在我们的应用场景中，经常有一些DTO设计的很复杂(参与传输的字段很多)，
但是每次使用这个DTO的时候，根据使用场景的不同，我们也许只会使用它其中的少量字段，也就是说，剩余的字段都是一些
默认值！  经过反复的思考，我们认定，当可参与传输的字段总是经常性拥有默认值的时候，其实它并不应该会参与到传输中去，
因为在反序列化的过程中，这个值如果不存在于数据里面，那么也将把它设置为默认值。 
    所以经过我们的思考，最终加入了这个新的功能。 这个新功能的加入直接减少了网络传输中的数据大小。但是，这个新功能
对于可参与传输的字段来说，并不是默认开启的。 如果你想对于某些可传输字段使用此新功能，那么你必须要将这个字段标记为上
IntellectProperty Attribute, 并且设置 IntellectProperty.AllowDefaultNull = true。
    当然，为了配合此次的新功能，我们还为框架中新增了一个异常类型: DefineNoMeaningException。
	这个类型可能会在第一次序列化指定对象，并在分析这个对象结构的情况下抛出。异常抛出的条件为: 你尝试为一个本身就是引用类型的
字段标记为IntellectProperty.AllowDefaultNull = true，或者你尝试为一个可空类型的字段标记为
IntellectProperty.AllowDefaultNull = true, 就像我们刚刚谈到的，这次的新功能，所支持的范围仅仅是简单的值类型。任何在使用上
的错误，我们都将会在第一次分析可序列化对象结构的时候抛出这个异常，所以，我们希望使用者能够留意日志中的这个异常类型，
来更加规范的设计我们项目中存在的可参与网络传输对象。
    我们的框架为了这次的新功能，还加入了一个新的类型: DefaultValue。 这个类里面给出了我们框架中所有支持
"值类型字段，默认值不参与传输"的默认值定义，如果你还不清楚，可以去这个类中查看。


**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-09-17更新
**********************************************************************************
在本次版本更新中，主要解决两个问题：
1.fastinvoke带来的拆装箱问题
	用MSIL封装了一个PropertySetStubHelper类，用泛型的方式动态的创建了CreateDelegate的实例从而解决了拆装箱的问题。
2.Array.SetValue带来的性能问题
	把所有以前用到Array.SetValue的地方全部后置到类型的Processor里面，全部用托管指针操作，对于大于10个元素的数组，采用
	内存一次拷贝的方式赋值，避免元素数量过多循环带来的内存开销。
上面两点的修改，使KJFramework.Messages框架的反序列化性能进一步得到提升，大概在50%左右。





**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-12-19更新
**********************************************************************************
1. 提升了字符串类型的解析性能，当要解析字符串的字符数量小于或者等于一定量时，新的功能将允许在线程栈上分配内存，而不是堆中。
    这样做法的好处是，能够屏蔽日常中遇到的小规模字符串总是会给GC造成一定量的负担。
2. 更新基础依赖库为最新版本，当然，内部对应的日志功能也会采用新的Tracing形式，而不是老的LOG。所有更新此版本的用户，
    需要将你们系统中的KJFramework配置节，添加新的日志功能配置节。 至于需要添加的具体内容，直接查看测试项目中的配置文件就可以了 :)









**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2012-12-24更新
**********************************************************************************
       这是一次基于易用性和性能平衡性的升级，由于在原来的版本中，内存CPY的细节上总是一贯性的使用WIN32 API，
从而导致了一部分性能损耗来自于PInvoke技术的封送和调用上。在新的版本中，我们采用了.NET内部的Marshal类
来进行一部分的内存CPY任务。
       有一部分使用者汇报，他们由于忘记把序列化的类型标记为public而导致了内部的异常。哦，是的，这是一个潜在的使用风险，
在原来的版本中，由于我们并没有刻意强调被序列化类型的public权限的重要性，从而导致了一部分用户的操作失误。在新的版本中
我们也为此地方加入了更新。如果被序列化的对象不是public权限，那么这个异常在KJFramework.Message内部不会被吃掉，
反而会抛给外部来处理，新的异常使用.NET BCL里面的MethodAccessException来代替，并且我们重置了里面的异常友好信息。
       另外，除了在IMemorySegmentProxy中加入了重载方法WriteMemory(byte[], uint, uint)来扩展通用性之外，通过使用
IMemorySegmentProxy后我们不难发现，里面的GetBytes(bool)方法定义的有些问题，在使用者眼里，应该在此方法内部总是自动的
回收资源(内存片段), 而不是等着外部传入一个回收资源的参数。在新的更新中，我们更新了此方法的声明以及内部的实现细节。
       当然了，在最后，我们重新跑完了所有的单元测试，并为本次更新的内容加入了相关的单元测试方法。




	   

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2013-01-05更新
**********************************************************************************
1. 在定义一个可传输的网络对象时，在一些场景下，可能会需要参与网络传输的字段被设计成inner set.
    在本次更新中，我们将会支持这样的功能。也就是说，当一个可参与网络传输的Property被设计成{get; private set;}
	的时候，依旧可以完成序列化/反序列化的任务。
2. 为本次的功能更新加入了必要的单元测试





	   

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2013-03-28更新
**********************************************************************************
1. 在过去的日志呈现方式中，我们总是会为二进制数来呈现到文本文件上的格式而发愁，现在，新的一个版本中，我们重写了
    关于这一部分的代码，您将会看到我们使用了一种新的，更加正式的方式来将二进制数组呈现到文本文件中。
2. 重新规整了DataHelper(轻量级序列化帮助器), 重整后的效果，使其能够支持上一个版本的优化策略(使用非托管内存来序列化)
3. 随着针对于序列化和反序列化的优化策略，我们不难发现，我们为IIntellectTypeProcessor接口中添加了太多的重载方法，以至于当我们
    开发一个支持新类型的IIntellectTypeProcessor时感到束手无策，因为我们不得不要完成接口中的每一个方法。在新的版本中，我们也
	考虑到了这点，我们移除了在IIntellectTypeProcessor接口中无用的或冗余的方法，这样就可以使我们的使用者，将精力放在重点的方法上。
4. 为DataHelper增加了单元测试







	   

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2013-04-01更新
**********************************************************************************
1. 解决了一个BUG， 该BUG会导致，当一个智能对象的内部字段类型是一个智能对象数组的时候，
   反序列化出来的结果直接会成为IntellectObject[]类型，而无法转换为用户期待的对象字段类型。




   

	   

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2013-04-07更新
**********************************************************************************
在上一次更新后，我们惊奇的发现，在反序列化的一定量级操作上，居然比原来慢了不少。经过一定量的分析后，
我们不难得出慢的原因是出在了Activator.CreateInstance()这个方法上。
于是乎，我们在KJFramework.Message内部，创建了一个新的帮助类(IntellectObjectArrayHelper)，
我们使用这个帮助类来完成反序列化中"智能对象相关类型"数组的创建工作。

通过本次的更新后，反序列化的一定量级操作上，平均耗时下降了300ms, 已经恢复到原有的速度了。




   

	   

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2013-05-07更新
**********************************************************************************
在实际的应用中，根据业务需求我们需要传输一些大数据量的对象，而往往那些大数据量的对象
所序列化出来的结果是很大的。比如3M，5M等等。KJFramework.Message率先察觉到了此种需求
的存在，特地在本次更新中加入了新的数据类型 Blob.

Blob类型，顾名思义是支持大数据的，这个对象的入口参数需要被传递一个需要进行压缩的字节数组。
而Blob类型内部自带的压缩效果(目前仅支持GZip/BZip2)，将会很好的支持大数据量压缩序列化。
我们需要在初始化Blob对象的时候，为其指定一个压缩算法。

在KJFramework.Message内部的日志输出上，也为Blob对象做出了特殊处理。考虑到Blob对象内部所包含的数据
通常会很大，而这样大的数据打到日志文件上会产生很"可观"的文件大小，所以我们这次破例，不会在日志描述信息中
输出Blob类型内部的数据细节，而恰恰相反，当您调用Blob类型的ToString()方法时, 它将会输出内部数据的统计信息，
比如原始大小，压缩后大小，压缩比例等等数据 :)

另外，我们为本次的新数据类型增加了单元测试。






   

	   

**********************************************************************************
*	KJFramework.Messages 智能二进制消息框架
*	2013-08-07更新
**********************************************************************************
1.为BitFlag对象增加了实例方法: GetData()，调用者可以使用此方法获取BitFlag对象内部的字节数据