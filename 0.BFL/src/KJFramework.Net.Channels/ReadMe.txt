**********************************************************************************
*
*	KJFramework.Net.Channel 通信信道模型框架
*
**********************************************************************************
[说明：]
    KJFramework框架中内置了一套通信信道模型框架，该框架规整了目前KJFramework内部
使用的所有信道模型，并以此为基础向上层构建扩展点。KJFramework提倡使用通信信道模型
作为网络通讯的基础组件，并以此作为高性能网络通讯的起点。

[发展方向]
	1. Network channel mode.
	2. Parallel channel mode.
	3. Channel group mode.




----------------------------------------------------------------------------
- 项目进度: 2011-08-03
----------------------------------------------------------------------------
1. 初步规划了需要整合的信道范围
2. 将原有信道代码与现有设计做了初步兼容
3. 设计了全新的消息信道接口(IRawTransportChannel, IMessageTransportChannel)
4. 为信道与协议栈(ProtocolStack)整合做出了基础支持
5. 创建了项目：KJFramework.Net.Channels.UnitTest，用于单元测试
6. 为PipeHostTransportChannel, TcpHostTransportChannel, TcpTransportChannel做了初步的单元测试




----------------------------------------------------------------------------
- 项目进度: 2011-08-04
----------------------------------------------------------------------------
1. 使用缓存模型框架(KJFramework.Cache)池化了SocketAsyncEventArgs.
2. 优化了TcpTransportChannel内部Send方法，变为使用缓存的SocketAsyncEventArgs.
3. 更改了TcpTransportChannel.Connected属性判定值的BUG，修改后的逻辑为: 与内部Socket进行关联.
4. 为命名传输信道(PipeTransportChannel)做了单元测试






----------------------------------------------------------------------------
- 项目进度: 2011-08-08
----------------------------------------------------------------------------
1. 为通信信道模型框架增加了对于HTTP协议的基础支持(HttpHostTransportChannel, HttpTransportChannel).
2. 为HTTP协议宿主信道做了单元测试
3. 为HTTP协议传输信道做了单元测试
4. 为通信信道模型框架增加了封包最大字节数限制
5. 更新了IMessageTransportChannel.Send(T message)方法逻辑。
	修改后的逻辑为：如果发现要发送的数据大于现有配置项，则改用IProtocolStack.ConvertMultiMessage






----------------------------------------------------------------------------
- 项目进度: 2011-08-11
----------------------------------------------------------------------------
1. 将PipeTransportChannel中发送数据的部分改为APM模式。
2. 修正了PipeStreamTransaction中，无法多次读取数据的BUG
3. 修正了多处对于PipeStream判断不严谨的地方。




----------------------------------------------------------------------------
- 项目进度: 2011-08-12
----------------------------------------------------------------------------
1. 鉴于在消息信道(IMessageChannel)外部做分包处理流程过于复杂，特地在框架内部增加了对于封包片的支持.
	(1). 增加了封包片存根接口(IMultiPacketStub)
	(2). 增加了封包片管理器接口(IMultiPacketManager), 外部用户可以继承此接口的抽象父类，来自行完成内部
		  的消息拼接工作。



----------------------------------------------------------------------------
- 项目进度: 2011-09-20
----------------------------------------------------------------------------
1. 移除了对于DuplexChannel的设计，如果需要使用双向通道，则直接使用RawChannel即可.
2. 为输入输出通道做了重新的设计(OutputChannel, InputChannel)
	* 一个支持只收不发
	* 一个支持只发不收(rsp message except)
	通过将输入输出通道设计为与基于流的传输信道组合，系统底层将会给予使用者最大限度的灵活度。
	既， 其实无论是OutputChannel 还是 InputChannel 都看做是一个限制的shell而已 :)

	

----------------------------------------------------------------------------
- 项目进度: 2011-09-28
----------------------------------------------------------------------------
1. 创建了事务的概念(ITransaction), 该设计将事务分为2类:
		#可执行和回滚的事务(IExecutableTransaction)
		#消息事务(IMessageTransaction)
	将事务与生命周期租约相结合，也就在侧面上给予了一个事务可超时的能力
2. 为可执行事务以及消息事务创建了父类
3. 设计了事务管理器接口(ITransactionManager), 并实现了该接口




----------------------------------------------------------------------------
- 项目进度: 2011-10-10
----------------------------------------------------------------------------
1. 修改了SocketIoDataStub.Clear()方法




----------------------------------------------------------------------------
- 项目进度: 2011-10-14
----------------------------------------------------------------------------
1. 修改了MessageTransportChannel内部的基础信道断开时，所导致了栈溢出异常
2. 修改了当MessageTransportChannel断开时，无法获取MessageTransportChannel.Key字段值的问题





----------------------------------------------------------------------------
- 项目进度: 2011-11-09
----------------------------------------------------------------------------
1. 解决了一个很诡异的BUG，一个程序在第一次启动的时候，会收不到消息。 确切的说也不算是收不到消息，而是能接收到数据，
    但是消息信道的RecvData事件还没来得及被挂接，就接收到了数据，所以接收到的数据被抛弃了。
	#解决方案：
			1. 把通讯信道的接收数据工作分开，必须调用ITransportChannel.Open()方法，才会开始接收数据。
			    (当然，最终级别的通讯信道会重写InnerOpen方法，来达到自身的逻辑隔离)