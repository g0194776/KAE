*****************************************************
*部署结论：
*1.每个组件的所有依赖组件必须都要放到指定组件的文件夹内
*2.动态服务可执行程序中每个依赖组件都必须放到当前自己的目录下
*3.有特殊依赖的话，必须也要COPY到服务执行器目录下
*4.将拥有特殊配置节的配置文件插入到默认的服务部署配置文件中
*****************************************************

KJFramework.Dynamic 动态服务框架介绍

      KJFramework内置了一套基于组件模式的动态服务解决方案，该解决方案被命名为: KJFramework.Dynamic(动态服务框架).
使用者可以通过使用动态服务框架来构建自己的服务，由于该框架是基于组件模式设计的，所以在使用本框架时，
最起码要对自己的服务进行足够多的业务了解，只有这样，才能为一个服务分为多个逻辑层次，每个逻辑层次互相独立(当然，也可以互相通讯)。
我们提倡，为每一个已分割的逻辑层单独设计成为一个组件(Component), 该组件派生自DynamicDomainComponent即可。
当然，我们还需要一个动态服务类，用户直接使用框架内部的DynamicDomainService即可。 在一般场景下，我们会在一个可执行程序中
去初始化我们的DynamicDomainService。 而在DynamicDomainService内部，它将会初始化每一个属于自己的组件。
     在框架内部, 我们为组件设计了通讯隧道(Tunnel)的能力，一个通讯隧道(Tunnel)，在组件内部表示为一个IPC通讯信道。
这种通讯信道，直接的为同一个进程跨组件的数据交互提供了高性能的通讯能力。当然，我们并不会把一个赤裸裸的IPC通讯信道暴露给使用者，
因为这是非常丑陋的。 我们会使用一个KJFramework内部的RPC框架对该IPC通讯信道进行包装。也就是说，用户只需要简简单单的为需要
组件间交互的数据设计一个RPC服务接口和实现即可。 我们的动态组件(Component)将会有能力来帮助使用者自动的去开放这个RPC服务。
    在组件内部，我们可以通过使用隧道访问者(Tunnel Visitor)来访问同一个进程内部其余组件所开放的RPC服务(当然，前提是要访问的组件开放了RPC服务)，
请不要担心，我们在这里为使用者设计了最简易的使用方式，一个组件想调用另一个组件所开放的RPC，只需要为一个隧道访问者(Tunnel Visitor)传递
目标组件的名称即可，隧道访问者(Tunnel Visitor)将会自动找到目标组件的RPC服务地址，并且进行连接。
    如果您选择使用KJFramework.Dynamic(动态服务框架)来构建服务，那么很荣幸，框架内部已经为您的服务和组件提供了动态更新的能力。
您需要做的，仅仅是在需要动态更新的场景下，去调用DynamicDomainService的相关能力即可，这一切都是那么的简单。






######################################################
#	Date : 2010-06-08
#  Version : 0.0.0.1 
######################################################
当前要思考的问题：
------------------------------------------------------
1. 总控制平台所控制的元素，到底是一个Windows Service, 还是一个IDynamicDomainService?
	(1). 如果是一个Windows Service, 那么控制点到底是什么？ 难道要设置整个服务的开启或关闭？这样的做法是否有意义。
2. 到底需不需要DynamicDomainServiceRegistation。
3. 服务动态安装/部署的问题。
4. 关于架构组件结构的决策：Controller -> Windows Service->Dynamic Domain Service->DynamicDomainComponent, 需要评估这样的合理性。

######################################################
#	Date : 2010-06-21
#  Version : 0.0.0.1 
######################################################
1. 添加了访问规则表，在动态程序域组件中，这样的设计使得组件内部对于外部的访问达到了可控。
2. 修改了访问器(Visitor)对于动态程序域组件内部组件的访问规则。
3. 添加了服务安装器。
4. 添加了服务模板(Service Shell)。
5. 更新了Dynamic Service Object的内部运行流程。
6. 已经初步拟定了“动态程序域服务”的结构，以及内部运行和更新的流程。
7. 初步的为Dynamic Domain Service创建了性能监控器，这样的设计使得动态程序域服务将会承担起自身所有组件的性能监控任务。

######################################################
#	Date : 2010-06-28
#  Version : 0.0.0.1 
######################################################
1. 更新了访问者(DynamicObjectVisitor)内部路由组件的逻辑。
2. 修改了3处获取动态对象的BUG。

######################################################
#	Date : 2010-07-20
#  Version : 0.0.0.1 
######################################################
1. 修改了一处可能导致内存溢出的BUG。
2. 更正了一处死锁的BUG。




######################################################
#	Date : 2010-07-21
#  Version : 0.0.0.1 
######################################################
1. 增加了所谓的“监控模型”
    (1). Dynamic Service -> Dynamic Component
	(2). Sub Machine Controller -> Dynamic Service
	(3). Service Machine Center -> Sub Machine Controller
2. 编写了对于Sub Machine Controller 对外暴露的契约。
	(1). Control Contract (Pipe network type.)
	(2). Management Contract (TCP network type.)


下一步要做的事情：
---------------------------------------------------------
1. 等待ServiceModel对于TCP协议的支持。
2. 构建Sub Machine Controller。
3. 实现Dynamic Service与Sub Machine Controller的首次连接。


######################################################
#	Date : 2010-07-27
#  Version : 0.0.0.1 
######################################################
1. 构建了支持中心（用来支持上层基础服务）。
2. 初步构建了Sub Machine Controller。
3. 修改了动态程序域组件内部记录日志的BUG。
4. 优化了动态程序域组件的执行流程。
5. 新增了控制中心URL（用来做最小粒度的控制）。
6. 增加了控制中心URL关心度标示（是指如何能够不配置CENTER URL而保持良好工作）。
7. 重新设计了低层次服务开放的服务契约。
8. 一个新的设计（支持中心 - SupportCenter）。
9. 更改了模板服务（Template Service）启动核心程序（Core Moudle）的执行流程。



######################################################
#	Date : 2010-07-28
#  Version : 0.0.0.1 
######################################################
1. 增加了动态程序域服务自更新契约的开放（使用PIPE信道）





######################################################
#	Date : 2011-01-21
#  Version : 0.0.0.1 
######################################################
1. 删除了所有冗余的代码
2. 清除了DynamicService, DynamicComponent, DynamicObject中所有跟框架无关的东西(开放RPC, 汇报状态等等)
3. 更新了DynamicService, DynamicComponent, DynamicObject内部的部分代码，让逻辑更清晰
4. 今后KJFramework.Dynamic框架将会定位为Common级别的架构，而不拘泥于某个平台的细节。



######################################################
#	Date : 2011-02-13
#  Version : 0.0.0.1 
######################################################
1. 修正了Visitor中不正确的设计思路
2. 将Component中的RuleTable设置为程序集共享模式，是外界无法直接访问





######################################################
#	Date : 2011-03-01
#  Version : 0.0.0.1 
######################################################
1. 为应用程序域组件(Dynamic Domain Component)的相互通讯，设计了隧道(Tunnel)技术。通过在2个不同组件中使用隧道技术来通讯，将会使跨域封送的成本降为最低。
2. 为应用程序域组件(Dynamic Domain Component)的相互通讯，设计了组件隧道访问者， 一个组件可以通过这个访问者来创造与其他组件互相通讯的隧道。




######################################################
#	Date : 2011-05-13
#  Version : 0.0.0.1 
######################################################
1. 大范围更新了组件隧道技术的实现细节(Component Tunnel)，修改后的逻辑为：
	已经不需要将组件隧道技术局限为一个公有契约接口， 而是可以允许使用者自定义属于自己的契约接口，这样做，将会最大化使用者的灵活度。而且还为契约传参的强类型检查
	做出了贡献。




######################################################
#	Date : 2011-06-21
#  Version : 0.0.0.1 
######################################################
1. 为动态程序域组件(DynamicDomainComponent)的UseTunnel方法，增加了一个是否支持开放元数据的标示




######################################################
#	Date : 2011-07-11
#  Version : 0.0.0.1 
######################################################
1. 为DynamicDomainService.Start清理失败的程序域对象添加了状态输出.
2. 纠正了一些状态输出内容的大小写问题






######################################################
#	Date : 2011-07-29
#  Version : 0.0.0.5 
######################################################
1. 修正了DynamicDomainService构造函数的BUG，统一了WorkRoot
2. 构造内部核心Component时，增加了对于ApplicationBase和ConfigurationFile的指定
3. 将内部的动态程序域对象集合由List改为KEY-VALUE的形式，并改为并发集合
4. 删除了输出信息时的一些无用字符
5. 看到没？ 就在今天，我将KJFramework.Dynamic框架的内部版本升级为了: 0.0.0.5 
	哦！ 这是多么令人激动地一刻，这个框架截止到今天为止，已经1年多了~






######################################################
#	Date : 2011-08-16
#  Version : 0.0.0.5 
######################################################
1. 更改内部开放隧道的依赖





######################################################
#	Date : 2011-11-01
#  Version : 0.0.0.5 
######################################################
1. 修正了框架内部的部分代码
2. 修改了一个无法动态更新的BUG，个人感觉这个BUG的起因应该是.NET自身的问题
3. 为IDynamicDomainComponent增加了OwnService字段
4. 修复了内部对于RPC框架的使用代码
5. 为动态程序域服务(IDynamicDomainService)添加了更新单个组件的能力





######################################################
#	Date : 2011-11-02
#  Version : 0.0.0.5 
######################################################
1. 将KJFramework.Dynamic.Template.Service项目挪动到解决方案里面来
2. 整理了所有项目的文件引用，为开源做准备




######################################################
#	Date : 2011-11-14
#  Version : 0.0.0.5 
######################################################
1. 调整了动态服务部署时候获取相关信息的策略，由原来程序员手工传入参数改为从配置文件中读取
2. 为配置文件加入了Service节点 -> Infomation节点
3. 加入了相关的配置文件





######################################################
#	Date : 2012-04-17
#  Version : 0.0.0.5 
######################################################
1. 如果具有多个组件，则启动组件的方式由原来的并行改为现在的串行
2. 如果一个动态服务不具有至少一个组件，则会无法启动