**********************************************************************************
*
*	KJFramework.Cache 缓存框架
*                   Codename: koala
**********************************************************************************
[说明：]
    KJFramework框架中集成了一套缓存框架(KJFramework.Cache)，用于对框架内部的缓存以及未来功能的实现提供基础支持。
KJFramework.Cache(缓存框架)内部应用了租赁者模式，将内存缓存(memory cache)做成了租赁的形式，用于提供更好的用户体验。
在框架内部, 我们提倡使用租赁者(ICacheTenant)接口，来做为操作缓存框架的入口点。
   在未来, KJFramework.Cache(缓存框架)将会朝向以下两个方向去发展:
   (1). Unmanaged memory cache.
   (2). IO cache.
   (3). Memory cache.



---------------------------------------------------------------------------
- 2011-07-18 项目进度
---------------------------------------------------------------------------
1. 创建了KJFramework.Cache项目
2. 创建了缓存生命周期的基本结构
3. 创建了缓存存根的基本结构(Cache Stub)
4. 创建了缓存容器的基本结构(Cache Container)
5. 为KJFramework.Cache框架应用了租赁者模式
6. 创建了租赁者接口(ICacheTenant)
7. 实现了IFixedCacheContainer.
8. 实现了ICacheContainer.
9. 设计了远程缓存代理器(IRemoteCacheProxy)
10. 创建了KJFramework.Cache的单元测试项目 KJFramework.Cache.UnitTest
11. 为FixedCacheContainer创建了单元测试




---------------------------------------------------------------------------
- 2011-07-20 项目进度
---------------------------------------------------------------------------
1. 为CacheContainer创建了单元测试
2. 为FixedCacheContainer设计了IClearable接口
3. 重写了CacheStub内部针对于FixexCache的部分逻辑，移除了Clear方法
4. 更新了FixedCacheContainer内部的部分逻辑
5. 为远程缓存代理器(IRemoteCacheProxy)创建了抽象父类
6. 重置了内部Cache相关的访问权(public -> internal)， 重置访问权限后，外界完全按照接口契约来访问
7. 为缓存租户(CacheTenant)做了单元测试




---------------------------------------------------------------------------
- 2011-07-25 项目进度
---------------------------------------------------------------------------
1. 为非托管内存建立了基础结构(IUnmanagedCacheStub, IUnmanagedCacheItem)
2. 为使用者提供了外部的非托管缓存接口(IUnmanagedCacheSlot)
3. 当前内部的非托管内存基础结构，没有采用生命周期的管理策略，所以当前的内存回收要由使用者自己来完成
	使用者可以通过调用 IUnmanagedCacheSlot.Discard() 方法来完成非托管内存的回收工作，同时也会放弃掉当前的缓存。
4. 为UnmangedCacheSlot做了单元测试




---------------------------------------------------------------------------
- 2011-07-26 项目进度
---------------------------------------------------------------------------
1. 为片段式内存缓存建立了基础结构(ISegmentCacheItem, ISegmentCacheStub)
2. 为SegmentCacheStub做了单元测试
3. 创建缓存索引器思想(ICacheIndexer)，为片段式内存缓存做服务
4. 这次的片段式内存缓存，默认是想用户直接构造size > 85000大小，然后直接将一整段内存放到LOH中，避免性能开销。
    在内部，我们将会根据用户指定的片段等级，为这一整块内存进行分区管理，已达到最小化的空间损失。



	
---------------------------------------------------------------------------
- 2011-07-27 项目进度
---------------------------------------------------------------------------
1. 建立了片段式缓存容器(ISegmentCacheContainer)，该容器支持使用者自定义内部的分片等级和大小
2. 为片段式缓存容器(ISegmentCacheContainer)做了单元测试
3. 为片段式缓存容器(ISegmentCacheContainer)编写了自动搜索合适分片内存的算法
4. 创建了项目: KJFramework.Cache.Performances.Segment 用于为片段式缓存容器(ISegmentCacheContainer)作压力测试
5. 创建了高速分段缓存接口IHightSpeedSegmentCache, 用于支持内部的性能优化方案
6. 创建了分段式缓存策略接口(ISegmentCachePolicy)，此接口将会被使用者用于设置分片策略



	
---------------------------------------------------------------------------
- 2011-07-28 项目进度
---------------------------------------------------------------------------
1. 优化了片段式缓存容器(ISegmentCacheContainer)内部的内存分段选择算法




---------------------------------------------------------------------------
- 2011-08-01 项目进度
---------------------------------------------------------------------------
1. 扩充了非托管内存缓存槽(IUnmanagedCacheSlot)，使其内部的内存句柄可以被只读的权限访问
2. 更新了非托管内存缓存槽，存根的设计，使其支持了可以使用外部传入的内存句柄来初始化的能力
3. 为非托管内存缓存槽(IUnmanagedCacheSlot)添加了相应的单元测试




---------------------------------------------------------------------------
- 2011-08-03 项目进度
---------------------------------------------------------------------------
1. 为片段式缓存容器(ISegmentCacheContainer)增加了缓存过期事件
2. 调整了缓存租约(ICacheLease)的访问权限, 移除了ExpireTime的set权限，
	这样做的好处是，统一了外部接口的使用规范，统一使用ICacheLease.Renew()方法
	进行续约操作。






---------------------------------------------------------------------------
- 2011-11-02 项目进度
---------------------------------------------------------------------------
1. 设计了连续内存段缓存容器(IMemoryChunkCacheContainer), 此容器适用于大容量的内存段开辟，
	最适合的是网络字节数组的缓存。